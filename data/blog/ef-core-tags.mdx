---
title: EF Core Query Tags and Alternatives
date: "2020-03-07"
lastmod: "2020-09-20"
tags:
  - EF Core
  - .NET Core
  - Serilog
draft: false
summary: "How to trace and diagnose EF Core queries using TagWith, log scopes, and structured logging tools like Seq and Application Insights."
tldr: "Add TagWith and logging scope metadata to EF Core queries so slow SQL can be traced back to source code quickly."
images:
  - /content/images/2020/03/efcore-query-tags-hero-with-arrows.png
authors:
  - default
layout: PostSimple
---
**UPDATE:** Upgraded samples to EF Core 5. (you can find old sample code in [this branch](https://github.com/jernejk/EfCoreSamples.Logging/tree/dotnet-core-3.1/EfCoreSamples.Logging.Web))

When doing a performance review on client applications (and my friend's apps), I often see issues related to EF Core and most devs don't seem to notice them until they spiral out of control. When this happens, they don't know how to find problematic queries and then link them back to the original code.

In this blog post, I'll show you a couple of tricks on how to track your queries, so when you need to debug performance issues, you won't have a problem finding the problematic SQL query as well the code that generates it. You can also skip to the end of the recommended approach.

I'll assume that you have configured logging in your .NET Core application, but if you need instructions for that, go to [ASP.NET Core 3.0 + Serilog](https://jkdev.me/asp-net-core-serilog/). I recommend collecting the logs into Seq and/or Application Insights for later analysis.

## Tagging Queries

If you use EF Core 2.2+, you can easily track your queries by tagging them with `.TagWith()`.

```csharp
var list = await _context.Tweets
    .TagWith("GetTweets")
    .ToListAsync(cancellationToken)
    .ConfigureAwait(false);
```

This will add **GetTweets** into SQL statement, which can be seen in logs and even SQL Profiler.

```sql
-- GetTweets

SELECT [t].[Id], [t].[CreatedUtc], [t].[Message], [t].[Username]
FROM [Tweets] AS [t]
```

**Figure:** We can see the tag as part of the query.

![efcore-logging-query-tag](/content/images/2020/02/efcore-logging-query-tag.png)

Query Tags are supported to any [IQueryable&lt;T&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.linq.iqueryable?view=netcore-3.1). This includes methods like `FromSqlRaw` which are now being used to execute store procedures and views as long it inherits from `IQueryable<T>`.

Sadly adding, updating and removing entities is not supported by Query Tags.

**NOTE:** For EF6 you can try to use this 3rd party Nuget package: [EF6.TagWith](https://www.nuget.org/packages/EF6.TagWith/)

## Log Scope

The second approach is to add Log Scope. This approach is great if `.TagWith()` isn't available. This could be because you want to log inserts/updates/deletes, you're running EF Core before version 2.2, legacy EF or even if you don't have direct access to the queries (like Microsoft Identity).

```CSharp
using (_logger.BeginScope(new Dictionary<string, object> { { "EFQueries", "GetTweets" } }))
{
    return await _context.Tweets
        .ToListAsync(ct)
        .ConfigureAwait(false);
}
```

![efcore-logging-log-scope-only](/content/images/2020/02/efcore-logging-log-scope-only-1.png)

In this example, I'll show you how you can indirectly log SQL statements generated by EF Core. To demonstrate that, we'll need to get an instance of ILogger and then we'll create a new Log Scope, which propagates to all logs inside that context.

```CSharp
public async Task InsertTweet(string username, string message, CancellationToken ct = default)
{
    // This can optionally be in the bellow log scope but is not necessary.
    // The tweet is going to be added into SQL DB when `.SaveChanges` is called.
    _context.Tweets.Add(new Tweet
    {
        Username = username,
        Message = message
    });
    
    using (_logger.BeginScope(new Dictionary<string, object> { { "EFQueries", "InsertTweet" } }))
    {
        // This will make SQL queries to save data into DB.
        await _context.SaveChangesAsync(ct).ConfigureAwait(false);
    }
}
```

**Figure:** Add tweet by adding it to Tweets table.

![efcore-logging-log-scope-insert](/content/images/2020/03/efcore-logging-log-scope-insert.png)

```CSharp
public async Task InsertTweet(string username, string message, CancellationToken ct = default)
{
    using (_logger.BeginScope(new Dictionary<string, object> { { "EFQueries", "InsertTweetStoreProc" } }))
    {
        InsertTweetInternal(username, message);
    }
}

private async Task InsertTweetInternal(string username, string message)
{
    // This query can also be outside this class and it would still be logged with the "EFQueries" scope. (EF Core 5 example)
    _ = await _context.Database
        .ExecuteSqlRawAsync(
            "InsertTweet @Username, @Message",
            new SqlParameter("Username", username),
            new SqlParameter("Message", message));
}
```

**Figure:** Insert Tweets with store procedure.

![efcore-logging-log-scope-store-procs](/content/images/2020/03/efcore-logging-log-scope-store-procs.png)

The above query might get lost if you have a lot of different queries, but by adding a Log Scope, we can search in your preferred rich logger aggregator like Seq or Application Insights for "InsertTweetStoreProc" in property "EFQueries".

This way, all queries are searchable based on context, find rogue queries and separate your queries from 3rd party queries. Now you can better focus on what queries to optimize or find original code that ran that query.

## Recommended approach

Depending on the project, Log Scope might be a better approach since now you can track every SQL query (and other logs) the same way. Use Log Scopes when you know that SQL Server is going to be a problem or visibility is more critical then compact code.

```csharp
using (_logger.EFQueryScope("GetTweetsLog"))
{
    return await _context.Tweets
        .TagWith("GetTweets + LogContext")
        .ToListAsync(ct)
        .ConfigureAwait(false);
}
```

Small utility for easier logging:

```csharp
public static class EFCoreLoggingUtils
{
    public static IDisposable EFQueryScope<T>(this ILogger<T> logger, string queryScopeName)
    {
        return logger.BeginScope(new Dictionary<string, object> { { "EFQueries", queryScopeName } });
    }

    public static IDisposable EFQueryScope(this ILogger logger, string queryScopeName)
    {
        return logger.BeginScope(new Dictionary<string, object> { { "EFQueries", queryScopeName } });
    }
}
```

![efcore-logging-full-log](/content/images/2020/02/efcore-logging-full-log.png) **Figure: Logs in Seq with Query Tags and Log Scopes.**

  

In Seq and Application Insights you can find all queries with the following filter `SourceContext = "Microsoft.EntityFrameworkCore.Database.Command"`. You can then do further filtering based on Log Scope by filtering `EFQueries`.

You can find source code here: [https://github.com/jernejk/EfCoreSamples.Logging](https://github.com/jernejk/EfCoreSamples.Logging)
